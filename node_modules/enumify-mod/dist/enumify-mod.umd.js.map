{"version":3,"file":"enumify-mod.umd.js","sources":["../src/enumify-mod.ts"],"sourcesContent":["/**\r\n * Created by Sergey Daniloff on 23-Aug-2017.\r\n * Based on enumify idea - https://github.com/rauschma/enumify and proposal http://goo.gl/XCh8Lc\r\n */\r\n\r\nconst INITIALIZED = Symbol();\r\n\r\nexport type EnumArgType = any[] | object;\r\n\r\n/**\r\n * This is an abstract class that is not intended to be\r\n * used directly. Extend it to turn your class into an enum\r\n * (initialization is performed via `MyClass.initEnum()`).\r\n */\r\nexport class Enum {\r\n  public static enumValues: any;\r\n  public name: string;\r\n\r\n  /**\r\n   * `initEnum()` closes the class. Then calling this constructor\r\n   * throws an exception.\r\n   *\r\n   * If your subclass has a constructor then you can control\r\n   * what properties are added to `this` via the argument you\r\n   * pass to `super()`. No arguments are fine, too.\r\n   */\r\n  constructor(instanceProperties: object) {\r\n    // new.target would be better than this.constructor,\r\n    // but isn’t supported by Babel\r\n    if ({}.hasOwnProperty.call(this.constructor, INITIALIZED)) {\r\n      throw new Error('Enum classes can’t be instantiated');\r\n    }\r\n    if (typeof instanceProperties === 'object' && instanceProperties !== null) {\r\n      copyProperties(this, instanceProperties);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create new Enum by name and description\r\n   * @param {string} enumName, enum name, used in `toString`\r\n   * @param {EnumArgType} arg Describing new fields of enum\r\n   * @returns {any}\r\n   */\r\n  public static create(enumName: string, arg: EnumArgType): any {\r\n    const newEnum = class extends Enum {};\r\n    newEnum.prototype.constructor = new Function(\r\n      `return function ${enumName}() {}`\r\n    )();\r\n    return newEnum.initEnum(arg);\r\n  }\r\n  /**\r\n   * Set up the enum, close the class.\r\n   *\r\n   * @param arg Either an object whose properties provide the names\r\n   * and values (which must be mutable objects) of the enum constants.\r\n   * Or an Array whose elements are used as the names of the enum constants\r\n   * The values are create by instantiating the current class.\r\n   */\r\n  public static initEnum(arg: EnumArgType) {\r\n    Object.defineProperty(this, 'enumValues', {\r\n      value: [],\r\n      configurable: false,\r\n      writable: false,\r\n      enumerable: true,\r\n    });\r\n    if (Array.isArray(arg)) {\r\n      this._enumValuesFromArray(arg, this); // Typescript not support ES6 version\r\n    } else {\r\n      this._enumValuesFromObject(arg);\r\n    }\r\n    Object.freeze(this.enumValues);\r\n    let ctx: any = this;\r\n    ctx[INITIALIZED] = true;\r\n    return ctx;\r\n  }\r\n\r\n  /**\r\n   * Get Enum instance by value\r\n   * @param value\r\n   */\r\n  public static fromValue(value: any) {\r\n    return this.enumValues.find((x: any) => x.value === value);\r\n  }\r\n\r\n  /**\r\n   * Get Enum instance by name\r\n   * @param {string} name\r\n   */\r\n  public static fromName(name: string) {\r\n    return this.enumValues.find((x: any) => x.name === name);\r\n  }\r\n\r\n  /**\r\n   * Make enum classes iterable\r\n   */\r\n  public static [Symbol.iterator]() {\r\n    return this.enumValues[Symbol.iterator]();\r\n  }\r\n\r\n  private static _enumValuesFromArray(arr: any[], context: any) {\r\n    for (const key of arr) {\r\n      this._pushEnumValue(new context(), key);\r\n    }\r\n  }\r\n\r\n  private static _enumValuesFromObject(obj: any) {\r\n    Object.keys(obj).forEach((key: string) => {\r\n      let keyValue = obj[key];\r\n      if (typeof keyValue !== 'object') {\r\n        keyValue = {\r\n          value: obj[key],\r\n        };\r\n      }\r\n      const value = new this(keyValue);\r\n      this._pushEnumValue(value, key);\r\n    });\r\n  }\r\n\r\n  private static _pushEnumValue(enumValue: any, name: string) {\r\n    enumValue.name = name;\r\n    if (typeof enumValue.value === 'undefined') {\r\n      enumValue.value = this.enumValues.length;\r\n    }\r\n    enumValue.valueOf = function valueOf() {\r\n      return this.value;\r\n    };\r\n    Object.defineProperty(this, name, {\r\n      value: enumValue,\r\n      configurable: false,\r\n      writable: false,\r\n      enumerable: true,\r\n    });\r\n    this.enumValues.push(enumValue);\r\n  }\r\n\r\n  /**\r\n   * Default `toString()` method for enum constant.\r\n   */\r\n  public toString() {\r\n    return `${this.constructor.name}.${this.name}`;\r\n  }\r\n}\r\nfunction copyProperties(target: object, source: object) {\r\n  // Ideally, we’d use Reflect.ownKeys() here,\r\n  // but I don’t want to depend on a polyfill\r\n  for (const key of Object.getOwnPropertyNames(source)) {\r\n    const desc = Object.getOwnPropertyDescriptor(source, key);\r\n    Object.defineProperty(target, key, desc);\r\n  }\r\n  return target;\r\n}\r\n"],"names":[],"mappings":"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"}