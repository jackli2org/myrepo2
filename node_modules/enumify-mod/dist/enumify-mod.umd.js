(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.enumifyMod = {})));
}(this, (function (exports) { 'use strict';

/**
 * Created by Sergey Daniloff on 23-Aug-2017.
 * Based on enumify idea - https://github.com/rauschma/enumify and proposal http://goo.gl/XCh8Lc
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var INITIALIZED = Symbol();
/**
 * This is an abstract class that is not intended to be
 * used directly. Extend it to turn your class into an enum
 * (initialization is performed via `MyClass.initEnum()`).
 */
var Enum = (function () {
    /**
     * `initEnum()` closes the class. Then calling this constructor
     * throws an exception.
     *
     * If your subclass has a constructor then you can control
     * what properties are added to `this` via the argument you
     * pass to `super()`. No arguments are fine, too.
     */
    function Enum(instanceProperties) {
        // new.target would be better than this.constructor,
        // but isn’t supported by Babel
        if ({}.hasOwnProperty.call(this.constructor, INITIALIZED)) {
            throw new Error('Enum classes can’t be instantiated');
        }
        if (typeof instanceProperties === 'object' && instanceProperties !== null) {
            copyProperties(this, instanceProperties);
        }
    }
    /**
     * Create new Enum by name and description
     * @param {string} enumName, enum name, used in `toString`
     * @param {EnumArgType} arg Describing new fields of enum
     * @returns {any}
     */
    Enum.create = function (enumName, arg) {
        var newEnum = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return class_1;
        }(Enum));
        newEnum.prototype.constructor = new Function("return function " + enumName + "() {}")();
        return newEnum.initEnum(arg);
    };
    /**
     * Set up the enum, close the class.
     *
     * @param arg Either an object whose properties provide the names
     * and values (which must be mutable objects) of the enum constants.
     * Or an Array whose elements are used as the names of the enum constants
     * The values are create by instantiating the current class.
     */
    Enum.initEnum = function (arg) {
        Object.defineProperty(this, 'enumValues', {
            value: [],
            configurable: false,
            writable: false,
            enumerable: true,
        });
        if (Array.isArray(arg)) {
            this._enumValuesFromArray(arg, this); // Typescript not support ES6 version
        }
        else {
            this._enumValuesFromObject(arg);
        }
        Object.freeze(this.enumValues);
        var ctx = this;
        ctx[INITIALIZED] = true;
        return ctx;
    };
    /**
     * Get Enum instance by value
     * @param value
     */
    Enum.fromValue = function (value) {
        return this.enumValues.find(function (x) { return x.value === value; });
    };
    /**
     * Get Enum instance by name
     * @param {string} name
     */
    Enum.fromName = function (name) {
        return this.enumValues.find(function (x) { return x.name === name; });
    };
    /**
     * Make enum classes iterable
     */
    Enum[Symbol.iterator] = function () {
        return this.enumValues[Symbol.iterator]();
    };
    Enum._enumValuesFromArray = function (arr, context) {
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var key = arr_1[_i];
            this._pushEnumValue(new context(), key);
        }
    };
    Enum._enumValuesFromObject = function (obj) {
        var _this = this;
        Object.keys(obj).forEach(function (key) {
            var keyValue = obj[key];
            if (typeof keyValue !== 'object') {
                keyValue = {
                    value: obj[key],
                };
            }
            var value = new _this(keyValue);
            _this._pushEnumValue(value, key);
        });
    };
    Enum._pushEnumValue = function (enumValue, name) {
        enumValue.name = name;
        if (typeof enumValue.value === 'undefined') {
            enumValue.value = this.enumValues.length;
        }
        enumValue.valueOf = function valueOf() {
            return this.value;
        };
        Object.defineProperty(this, name, {
            value: enumValue,
            configurable: false,
            writable: false,
            enumerable: true,
        });
        this.enumValues.push(enumValue);
    };
    /**
     * Default `toString()` method for enum constant.
     */
    Enum.prototype.toString = function () {
        return this.constructor.name + "." + this.name;
    };
    return Enum;
}());
function copyProperties(target, source) {
    // Ideally, we’d use Reflect.ownKeys() here,
    // but I don’t want to depend on a polyfill
    for (var _i = 0, _a = Object.getOwnPropertyNames(source); _i < _a.length; _i++) {
        var key = _a[_i];
        var desc = Object.getOwnPropertyDescriptor(source, key);
        Object.defineProperty(target, key, desc);
    }
    return target;
}

exports.Enum = Enum;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=enumify-mod.umd.js.map
